{"pageProps":{"title":"unique_ptr的缺陷","date":"2020-09-01T12:30:00.000Z","author":[{"name":"mq","link":""}],"html":"<h1>unique_ptr的缺陷</h1>\n<h2>unique_ptr 不能被优化为裸指针</h2>\n<ul>\n<li>尽管<code>sizeof(unique_ptr&lt;T, default_delete&lt;T&gt;&gt;) == sizeof(void*)</code>, ABI 限制了 unique_ptr 不能被寄存器传递, 而是传递 unique_ptr 的地址作为参数</li>\n</ul>\n<pre><code class=\"hljs\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;memory&gt;</span></span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">(<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">unique_ptr</span>&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; a)</span> </span>{\n    *a = <span class=\"hljs-number\">2</span>;\n}</code></pre><ul>\n<li>\n<p>MSVC汇编输出</p>\n<pre><code class=\"hljs\">a$ = 8\nvoid func(std::unique_ptr&lt;int,std::default_delete&lt;int&gt; &gt; &amp;) PROC ; func, COMDAT\n        mov     rax, QWORD PTR [rcx]\n        mov     DWORD PTR [rax], 2\n        ret     0\nvoid func(std::unique_ptr&lt;int,std::default_delete&lt;int&gt; &gt; &amp;) ENDP ; func</code></pre></li>\n<li>\n<p>clang汇编输出</p>\n<pre><code class=\"hljs\">func(std::unique_ptr&lt;int, std::default_delete&lt;int&gt; &gt;&amp;): # @func(std::unique_ptr&lt;int, std::default_delete&lt;int&gt; &gt;&amp;)\n        mov     rax, qword ptr [rdi]\n        mov     dword ptr [rax], 2\n        ret</code></pre></li>\n</ul>\n<p>均可以观察到两次内存地址mov</p>\n<p>而裸指针</p>\n<pre><code class=\"hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>* a)</span> </span>{\n    *a = <span class=\"hljs-number\">2</span>;\n}</code></pre><ul>\n<li>\n<p>MSVC</p>\n<pre><code class=\"hljs\">a$ = 8\nvoid func(int *) PROC                             ; func, COMDAT\n        mov     DWORD PTR [rcx], 2\n        ret     0\nvoid func(int *) ENDP                             ; func</code></pre></li>\n<li>\n<p>clang</p>\n<pre><code class=\"hljs\">func(int*):                              # @func(int*)\n        mov     dword ptr [rdi], 2\n        ret</code></pre></li>\n</ul>\n<h2>unique_ptr 不是 trivially movable</h2>\n<p>当<code>vector&lt;unique_ptr&lt;T&gt;&gt;</code>扩容时，vector调用了for循环依此move原buffer中的对象到新buffer，而不是memcpy</p>\n<p>当然这也怪C++没有destructive move语义，如果有的话，unique_ptr应当是&quot;trivially destructive movable&quot;</p>\n<p><code>reference_wrapper&lt;T&gt;</code>在此处与<code>unique_ptr&lt;T&gt;</code>有相同的问题</p>\n<h2>当API需要传递<code>T*[]</code>(裸指针的数组)时，<code>vector&lt;unique_ptr&lt;T&gt;&gt;</code> 就sb了</h2>\n<p>vector的data()是<code>unique_ptr&lt;T&gt;*</code>，不是<code>T**</code>，除非你<code>reinterpret_cast</code></p>\n<p><em>（不过话说回来，non-strict-aliasing也是ABI的一部分）</em></p>\n<h2>non-trivial的dtor可能会影响尾调用优化</h2>\n<p>众所周知，有non-trivial析构对象的函数的尾调用不是尾调用</p>\n<p><em>（吱又要喷我了，我不懂PTC，哪位巨巨给补充一下）</em></p>\n"},"__N_SSG":true}