<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>12k Tech Blog - unique_ptr的缺陷</title><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="https://unpkg.com/tachyons@4.10.0/css/tachyons.min.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous"/><link rel="stylesheet" href="/css/github-markdown.css"/><link rel="stylesheet" href="/css/highlight.css"/><script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script><script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/contrib/auto-render.min.js" integrity="sha384-yACMu8JWxKzSp/C1YV86pzGiQ/l1YUfE8oPuahJQxzehAjEt2GiQuy/BIvl9KyeF" crossorigin="anonymous"></script><meta name="next-head-count" content="9"/><link rel="preload" href="/_next/static/css/556eb87153dc9ca625fe.css" as="style"/><link rel="stylesheet" href="/_next/static/css/556eb87153dc9ca625fe.css"/><link rel="preload" href="/_next/static/css/47b2eccbc2f53b4c5bb6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/47b2eccbc2f53b4c5bb6.css"/><link rel="preload" href="/_next/static/chunks/main-794d8598b5f1f819e70a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-ccf5ab034a524403276a.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.6c6c2144b5674c37af03.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.c1da88ced54c9ffa7714.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-6b3651ecef8878c0ce3d.js" as="script"/><link rel="preload" href="/_next/static/chunks/99a17ff61bb56832986f97369f36a5b6e9c99511.4b656b6a47797cef6e06.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/post/%5B...all%5D-2d583e24f5dfdb34109a.js" as="script"/></head><body><div id="__next"><div><div class="relative bg-white Banner_banner__2vTsv"><div class="white pt6 pb5 Banner_banner_content__1HXXB"><h1 class="mv2 f2">12K Tech Blog</h1><div><a class="dib f6 white no-underline mr2" href="/">HOME</a><a class="dib f6 white no-underline mr2" href="https://github.com/12k-Tech-Group">GITHUB</a></div></div></div><main class="lh-copy"><div class="center mw6 ph4 pv3 bg-white markdown-body Post_markdown_body__1i0dP"><small class="mt1 db ttu o-40 Post_post_header__2ubQL"><span>佚名<!-- --> </span><time>2020/09/01</time></small><div><h1>unique_ptr的缺陷</h1>
<h2>unique_ptr 不能被优化为裸指针</h2>
<ul>
<li>尽管<code>sizeof(unique_ptr&lt;T, default_delete&lt;T&gt;&gt;) == sizeof(void*)</code>, ABI 限制了 unique_ptr 不能被寄存器传递, 而是传递 unique_ptr 的地址作为参数</li>
</ul>
<pre><code class="hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; a)</span> </span>{
    *a = <span class="hljs-number">2</span>;
}</code></pre><ul>
<li>
<p>MSVC汇编输出</p>
<pre><code class="hljs">a$ = 8
void func(std::unique_ptr&lt;int,std::default_delete&lt;int&gt; &gt; &amp;) PROC ; func, COMDAT
        mov     rax, QWORD PTR [rcx]
        mov     DWORD PTR [rax], 2
        ret     0
void func(std::unique_ptr&lt;int,std::default_delete&lt;int&gt; &gt; &amp;) ENDP ; func</code></pre></li>
<li>
<p>clang汇编输出</p>
<pre><code class="hljs">func(std::unique_ptr&lt;int, std::default_delete&lt;int&gt; &gt;&amp;): # @func(std::unique_ptr&lt;int, std::default_delete&lt;int&gt; &gt;&amp;)
        mov     rax, qword ptr [rdi]
        mov     dword ptr [rax], 2
        ret</code></pre></li>
</ul>
<p>均可以观察到两次内存地址mov</p>
<p>而裸指针</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a)</span> </span>{
    *a = <span class="hljs-number">2</span>;
}</code></pre><ul>
<li>
<p>MSVC</p>
<pre><code class="hljs">a$ = 8
void func(int *) PROC                             ; func, COMDAT
        mov     DWORD PTR [rcx], 2
        ret     0
void func(int *) ENDP                             ; func</code></pre></li>
<li>
<p>clang</p>
<pre><code class="hljs">func(int*):                              # @func(int*)
        mov     dword ptr [rdi], 2
        ret</code></pre></li>
</ul>
<h2>unique_ptr 不是 trivially movable</h2>
<p>当<code>vector&lt;unique_ptr&lt;T&gt;&gt;</code>扩容时，vector调用了for循环依此move原buffer中的对象到新buffer，而不是memcpy</p>
<p>当然这也怪C++没有destructive move语义，如果有的话，unique_ptr应当是&quot;trivially destructive movable&quot;</p>
<p><code>reference_wrapper&lt;T&gt;</code>在此处与<code>unique_ptr&lt;T&gt;</code>有相同的问题</p>
<h2>当API需要传递<code>T*[]</code>(裸指针的数组)时，<code>vector&lt;unique_ptr&lt;T&gt;&gt;</code> 就sb了</h2>
<p>vector的data()是<code>unique_ptr&lt;T&gt;*</code>，不是<code>T**</code>，除非你<code>reinterpret_cast</code></p>
<p><em>（不过话说回来，non-strict-aliasing也是ABI的一部分）</em></p>
<h2>non-trivial的dtor可能会影响尾调用优化</h2>
<p>众所周知，有non-trivial析构对象的函数的尾调用不是尾调用</p>
<p><em>（吱又要喷我了，我不懂PTC，哪位巨巨给补充一下）</em></p>
</div></div></main><footer class="center w5 f6 tc mt4 black"><p><span>© </span><span>2020-<!-- -->2020<!-- --> 12k Tech Blog</span></p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"unique_ptr的缺陷","date":"2020-09-01T04:27:45.562Z","author":[{"name":"佚名","link":""}],"html":"\u003ch1\u003eunique_ptr的缺陷\u003c/h1\u003e\n\u003ch2\u003eunique_ptr 不能被优化为裸指针\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e尽管\u003ccode\u003esizeof(unique_ptr\u0026lt;T, default_delete\u0026lt;T\u0026gt;\u0026gt;) == sizeof(void*)\u003c/code\u003e, ABI 限制了 unique_ptr 不能被寄存器传递, 而是传递 unique_ptr 的地址作为参数\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-meta-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-meta-string\"\u003e\u0026lt;memory\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003efunc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-built_in\"\u003estd\u003c/span\u003e::\u003cspan class=\"hljs-built_in\"\u003eunique_ptr\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e\u0026gt;\u0026amp; a)\u003c/span\u003e \u003c/span\u003e{\n    *a = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n}\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eMSVC汇编输出\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003ea$ = 8\nvoid func(std::unique_ptr\u0026lt;int,std::default_delete\u0026lt;int\u0026gt; \u0026gt; \u0026amp;) PROC ; func, COMDAT\n        mov     rax, QWORD PTR [rcx]\n        mov     DWORD PTR [rax], 2\n        ret     0\nvoid func(std::unique_ptr\u0026lt;int,std::default_delete\u0026lt;int\u0026gt; \u0026gt; \u0026amp;) ENDP ; func\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eclang汇编输出\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003efunc(std::unique_ptr\u0026lt;int, std::default_delete\u0026lt;int\u0026gt; \u0026gt;\u0026amp;): # @func(std::unique_ptr\u0026lt;int, std::default_delete\u0026lt;int\u0026gt; \u0026gt;\u0026amp;)\n        mov     rax, qword ptr [rdi]\n        mov     dword ptr [rax], 2\n        ret\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e均可以观察到两次内存地址mov\u003c/p\u003e\n\u003cp\u003e而裸指针\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003efunc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e* a)\u003c/span\u003e \u003c/span\u003e{\n    *a = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n}\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eMSVC\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003ea$ = 8\nvoid func(int *) PROC                             ; func, COMDAT\n        mov     DWORD PTR [rcx], 2\n        ret     0\nvoid func(int *) ENDP                             ; func\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eclang\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003efunc(int*):                              # @func(int*)\n        mov     dword ptr [rdi], 2\n        ret\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eunique_ptr 不是 trivially movable\u003c/h2\u003e\n\u003cp\u003e当\u003ccode\u003evector\u0026lt;unique_ptr\u0026lt;T\u0026gt;\u0026gt;\u003c/code\u003e扩容时，vector调用了for循环依此move原buffer中的对象到新buffer，而不是memcpy\u003c/p\u003e\n\u003cp\u003e当然这也怪C++没有destructive move语义，如果有的话，unique_ptr应当是\u0026quot;trivially destructive movable\u0026quot;\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ereference_wrapper\u0026lt;T\u0026gt;\u003c/code\u003e在此处与\u003ccode\u003eunique_ptr\u0026lt;T\u0026gt;\u003c/code\u003e有相同的问题\u003c/p\u003e\n\u003ch2\u003e当API需要传递\u003ccode\u003eT*[]\u003c/code\u003e(裸指针的数组)时，\u003ccode\u003evector\u0026lt;unique_ptr\u0026lt;T\u0026gt;\u0026gt;\u003c/code\u003e 就sb了\u003c/h2\u003e\n\u003cp\u003evector的data()是\u003ccode\u003eunique_ptr\u0026lt;T\u0026gt;*\u003c/code\u003e，不是\u003ccode\u003eT**\u003c/code\u003e，除非你\u003ccode\u003ereinterpret_cast\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e（不过话说回来，non-strict-aliasing也是ABI的一部分）\u003c/em\u003e\u003c/p\u003e\n\u003ch2\u003enon-trivial的dtor可能会影响尾调用优化\u003c/h2\u003e\n\u003cp\u003e众所周知，有non-trivial析构对象的函数的尾调用不是尾调用\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e（吱又要喷我了，我不懂PTC，哪位巨巨给补充一下）\u003c/em\u003e\u003c/p\u003e\n"},"__N_SSG":true},"page":"/post/[...all]","query":{"all":["2020","unique_ptr"]},"buildId":"PZ7nuBuBTulsY6UqnfCzx","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-c30a0338d988282f18a0.js"></script><script src="/_next/static/chunks/main-794d8598b5f1f819e70a.js" async=""></script><script src="/_next/static/chunks/webpack-ccf5ab034a524403276a.js" async=""></script><script src="/_next/static/chunks/framework.6c6c2144b5674c37af03.js" async=""></script><script src="/_next/static/chunks/commons.c1da88ced54c9ffa7714.js" async=""></script><script src="/_next/static/chunks/pages/_app-6b3651ecef8878c0ce3d.js" async=""></script><script src="/_next/static/chunks/99a17ff61bb56832986f97369f36a5b6e9c99511.4b656b6a47797cef6e06.js" async=""></script><script src="/_next/static/chunks/pages/post/%5B...all%5D-2d583e24f5dfdb34109a.js" async=""></script><script src="/_next/static/PZ7nuBuBTulsY6UqnfCzx/_buildManifest.js" async=""></script><script src="/_next/static/PZ7nuBuBTulsY6UqnfCzx/_ssgManifest.js" async=""></script></body></html>